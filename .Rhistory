isoinds<-read.csv("Isotria_Stage3_2016.csv", header=T)#
isoinds<-isoinds[-which(isoinds$UniqueID=="X-01-244"),]#individual has to be removed because of errors in its monitoring
isoinds[which(isoinds$UniqueID=="X-03-236" & isoinds$Year==2002),]$TotNoStems<-0#typo in "totnostems" column- says 1, but plant was dormant
setwd("~/git/isotria/analyses")
rm(list=ls())
options(stringsAsFactors=FALSE)
library(lme4)
#update.packages()
isoinds<-read.csv("Isotria_Stage3_2016.csv", header=T)#
isoinds<-isoinds[-which(isoinds$UniqueID=="X-01-244"),]#individual has to be removed because of errors in its monitoring
isoinds[which(isoinds$UniqueID=="X-03-236" & isoinds$Year==2002),]$TotNoStems<-0#typo in "totnostems" column- says 1, but plant was dormant
isoinds[which(isoinds$UniqueID=="Y-07-063" & isoinds$Year==2001),]$TotNoStems<-0#typo in "totnostems" column- says 1, but plant was dormant
#Add column for emergent/nonemergent
isoinds$Emerg<-NA
isoinds[which(isoinds$TotNoStems>0),]$Emerg=1
isoinds[which(isoinds$TotNoStems==0),]$Emerg=0
#Kirsi used the following emergent stages:smallveg, largeveg, flowering (i will include arrested in this- check with her if that's what she did) and fruiting, plus 2 dormant stages (dormant stage for previously small vegetative plants and dormant stage for everything else)
#i will follow these stages, which requires merging large and small fruiting plants in the stage3 column and mergeing large arrested/flowering with small arrested/flowering
#add column for Stage3, which is like Stage2 but merges  sm Arrested with sm Flowering abd Lg arrested withLg Flowering
isoinds$StageKirsi<-NA
isoinds[which(isoinds$Stage3=="ArFlLg"|isoinds$Stage3=="ArFlSm"),]$StageKirsi="fl"
isoinds[which(isoinds$Stage3=="FruitLg"|isoinds$Stage3=="FruitSm"),]$StageKirsi="fr"
#isoinds[which(isoinds$Stage3=="VegSm"),]$StageKirsi="sv"
#isoinds[which(isoinds$Stage3=="VegLg"),]$StageKirsi="lv"
isoinds[which(isoinds$Stage3=="VegLg"|isoinds$Stage3=="VegSm"),]$StageKirsi="v"#because for just groups x and y, there are not enough instantces of lv to estimate vital rates
isoinds[which(isoinds$Stage3=="D"),]$StageKirsi="d"
unique(isoinds$StageKirsi)
#need to use previous state to get 2 dormant stages
past = isoinds[isoinds$Year < 2015,]; past = past[order(past$UniqueID),]; past = past[order(past$Year),]
dim(past)# 32135 (dim(isoinds) is 32558 rows)
past$YearPrev=past$Year+1
head(past)
colnames(past)[5]<-"YearCurrent"
#Merge present and past to get fates
isoinds_prev<-merge(isoinds,past,by.x=c("UniqueID","Year","Group",  "Block", "Plant","YearFound"),by.y=c("UniqueID","YearPrev","Group",  "Block", "Plant","YearFound"),all.x = TRUE)#this includes all plants, without matches in past, as well
#delete unncessary columns (we only want stage)
isoinds_prev2=subset(isoinds_prev,select=c("UniqueID","Year", "Group",  "Block", "Plant",  "YearFound","Emerg.x","Emerg.y","StageKirsi.x","StageKirsi.y"))
#I want to add a column with a column to identify if a plant is dormant AND the last observed state was small vegetative
isoinds_prev2$dormstage=NA
isoinds_prev2[which(isoinds_prev2$StageKirsi.x=="d"),]$dormstage="d"
isoinds_prev2[which(isoinds_prev2$StageKirsi.y=="v" & isoinds_prev2$StageKirsi.x=="d"),]$dormstage="dv"
#isoinds_prev2[which(isoinds_prev2$StageKirsi.y=="lv" & isoinds_prev2$StageKirsi.x=="d"),]$dormstage="d"
isoinds_prev2[which(isoinds_prev2$StageKirsi.y=="fl" & isoinds_prev2$StageKirsi.x=="d"),]$dormstage="d"
isoinds_prev2[which(isoinds_prev2$StageKirsi.y=="fr" & isoinds_prev2$StageKirsi.x=="d"),]$dormstage="d"
unique(isoinds_prev2$dormstage)
for(i in 2:dim(isoinds_prev2)[1]){
ind<-isoinds_prev2[i,which(colnames(isoinds_prev2)=="UniqueID")]
currentstage<-isoinds_prev2[i,which(colnames(isoinds_prev2)=="StageKirsi.x")]
previousstage<-isoinds_prev2[i-1,which(colnames(isoinds_prev2)=="StageKirsi.x")]
previousdormstage<-isoinds_prev2[i-1,which(colnames(isoinds_prev2)=="dormstage")]
currentdormstage<-isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]
if(currentstage!="d"){next}
if(is.na(previousdormstage)) {if (currentstage=="d" & previousstage=="fl"|previousstage=="fr"){next}
else if (currentstage=="d" & previousstage=="v"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"dv"}}
else if(!is.na(previousdormstage)){
if(isoinds_prev2$UniqueID[i]==ind & currentstage=="d" & previousdormstage=="dv"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"dv"}
if(isoinds_prev2$UniqueID[i]==ind & currentstage=="d" & previousdormstage=="d"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"d"}
if(currentstage=="d" & isoinds_prev2[i-1,]$StageKirsi.x=="v"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"dv"}
if(currentstage=="d" & !is.na(currentdormstage)|previousdormstage!="dv"|isoinds_prev2[i-1,]$StageKirsi.x!="v"){next}
if(isoinds_prev2$UniqueID[i]==ind & currentstage=="d" & previousdormstage=="dv"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"dv"}
}
else if (isoinds_prev2$UniqueID[i]==ind & currentstage=="d" & previousdormstage=="d"){isoinds_prev2[i,which(colnames(isoinds_prev2)=="dormstage")]<-"d"}
}
head(isoinds_prev2)
#rename columns
colnames(isoinds_prev2)[7:10]<-c("Emerg_cur","Emerg_prev","Stage_cur","Stage_prev")
#now want to get fates of each plant
present = isoinds_prev2[isoinds_prev2$Year <2015 & isoinds_prev2$Year >1983, ]; present = present[order(present$UniqueID),]; present = present[order(present$Year),]
dim(present)# 31837, 11 columns
future = isoinds_prev2[isoinds_prev2$Year > 1984, ]; future = future[order(future$UniqueID),]; future = future[order(future$Year),]
dim(future)#31751 rows, 11 columns
head(present);head(future)
colnames(future)
future$YearFate=future$Year-1
#Merge present and future to get fates
isofate<-merge(present,future,by.x=c("UniqueID","Year","Group",  "Block", "Plant","YearFound"),by.y=c("UniqueID","YearFate","Group",  "Block", "Plant","YearFound"),all = TRUE)#this includes all plants, without matches in past/future, as well
isofate2<-merge(present,future,by.x=c("UniqueID","Year","Group",  "Block", "Plant","YearFound"),by.y=c("UniqueID","YearFate","Group",  "Block", "Plant","YearFound"))#this only includes plants for which there is fate data that matches
dim(isofate);dim(isofate2)
head(isofate2)
colnames(isofate)
isofate=isofate[,-12]#remove year column
isofate2=isofate2[,-12]
#add column names
colnames(isofate)=c("UniqueID","Year", "Group",  "Block", "Plant",  "YearFound","Emerg_cur","Emerg_prev","Stage_cur","Stage_prev","dormstage","FutEmerg","Emerg_REMOVE","Fate","Stage_cur2","dormstage_fut")
colnames(isofate2)=c("UniqueID","Year", "Group",  "Block", "Plant",  "YearFound","Emerg_cur","Emerg_prev","Stage_cur","Stage_prev","dormstage","FutEmerg","Emerg_REMOVE","Fate","Stage_cur2","dormstage_fut")
isofate<-subset(isofate,select=c("UniqueID","Year", "Group",  "Block", "Plant",  "YearFound","Emerg_cur","Emerg_prev","Stage_cur","dormstage","Stage_prev","FutEmerg","Fate","dormstage_fut"))
isofate2<-subset(isofate2,select=c("UniqueID","Year", "Group",  "Block", "Plant",  "YearFound","Emerg_cur","Emerg_prev","Stage_cur","dormstage","Stage_prev","FutEmerg","Fate","dormstage_fut"))
#I think I will mostly use isofate2, which only includes matches, so stick with that one for rest of formatting
#Add column for survival
#To do this,loop through each individual for each row, if dormant for less than 5 years, then alive. if not, then dead
#Include both dormant stages in Stage_cur
isofate2[which(isofate2$dormstage=="dv"),]$Stage_cur<-"dv"
isofate2$Stage_cur<-as.factor(isofate2$Stage_cur)
#Add column for Large (vs small)
isofate2$tov=0
isofate2[which(isofate2$Fate=="v"),]$tov=1
#Add column for Flowering(includes arrested) and Fruiting
isofate2$tofl=0
isofate2[which(isofate2$Fate=="fl"|isofate2$Fate=="fr"),]$tofl=1
#Add column for Fruiting
isofate2$tofr=0
isofate2[which(isofate2$Fate=="fr"),]$tofr=1
##Select out just groups X and Y for this analysis
groupX=isofate2[isofate2$Group=="X",]
groupY=isofate2[isofate2$Group=="Y",]
#some individuals have error in "year found column (X-07-235 is only one in groups x or y). for this individual, it was not actually observed in 2007 (emergence=0), so remnove this row
groupX<-groupX[-which(groupX$UniqueID=="X-07-235" & groupX$Year==2007),]
head(groupX)
###Fit binomial models for each transition to get vital rate estimates
#First, a model for emergence by stage
#observed emergence by stage
numsdsaliveX<-tapply(groupX$FutEmerg,list(groupX$Year,groupX$Stage_cur), sum)
numsdsX<-tapply(groupX$FutEmerg,list(groupX$Year,groupX$Stage_cur), length)
propemergX<-numsdsaliveX/numsdsX
propemergX#
numsdsaliveY<-tapply(groupY$FutEmerg,list(groupY$Year,groupY$Stage_cur), sum)
numsdsY<-tapply(groupY$FutEmerg,list(groupY$Year,groupY$Stage_cur), length)
propemergY<-numsdsaliveY/numsdsY
propemergY#
#Model for prob of emergence (need to condition this on survival, but have to model this first for dormant stages)
xemerg.mod <- glmer(FutEmerg ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=groupX, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#
yemerg.mod <- glmer(FutEmerg ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=groupY, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#
summary(xemerg.mod)#midentifiable with just vegetative state (with lv and sv, not identifiable)
B.xemerg.yr=coef(xemerg.mod)#
xprobemerg = exp(B.xemerg.yr$Year)/(1+exp(B.xemerg.yr$Year))#back-transformed= these are the probabilities of emergence,
colnames(xprobemerg)
write.csv(xprobemerg,"xprobemerg.csv")
summary(yemerg.mod)#summary(emerg.mod)
B.yemerg.yr=coef(yemerg.mod)#
yprobemerg = exp(B.yemerg.yr$Year)/(1+exp(B.yemerg.yr$Year))#back-transformed= these are the probabilities of emergence,
colnames(yprobemerg)
write.csv(yprobemerg,"yprobemerg.csv")
#Look at model estimates versus probabilities calculated from data to compare:
xemerg_mod_dat<-cbind(propemergX[,1],xprobemerg$Stage_curd,propemergX[,2],xprobemerg$Stage_curdv,propemergX[,5],xprobemerg$Stage_curv,propemergX[,3],xprobemerg$Stage_curfl,propemergX[,4],xprobemerg$Stage_curfr)
colnames(xemerg_mod_dat)<-c("pe_d_dat","pe_d_mod","pe_dv_dat","pe_dv_mod","pe_v_dat","pe_v_mod","pe_fl_dat","pe_fl_mod","pe_fr_dat","pe_fr_mod")
yemerg_mod_dat<-cbind(propemergY[,1],yprobemerg$Stage_curd,propemergY[,2],yprobemerg$Stage_curdv,propemergY[,5],yprobemerg$Stage_curv,propemergY[,3],yprobemerg$Stage_curfl,propemergY[,4],yprobemerg$Stage_curfr)
colnames(yemerg_mod_dat)<-c("pe_d_dat","pe_d_mod","pe_dv_dat","pe_dv_mod","pe_v_dat","pe_v_mod","pe_fl_dat","pe_fl_mod","pe_fr_dat","pe_fr_mod")
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(xemerg_mod_dat[,(i*2)-1],xemerg_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xemerg_mod_dat)[i*2],1,5)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yemerg_mod_dat[,(i*2)-1],yemerg_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yemerg_mod_dat)[i*2],1,5)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
#Model transitions across life stages
#2) for emergent plants, probability of flowering (which includes arrested)
emergX=groupX[groupX$FutEmerg==1,]
emergY=groupY[groupY$FutEmerg==1,]
emergX$Stage_cur<-factor(emergX$Stage_cur)
emergY$Stage_cur<-factor(emergY$Stage_cur)
emergX$Year<-factor(emergX$Year)
emergY$Year<-factor(emergY$Year)
xflow.mod <- glmer(tofl ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=emergX, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#probability of flowering conditioned on emergence
yflow.mod <- glmer(tofl ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=emergY, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#probability of flowering conditioned on emergence
B.xfl.yr=coef(xflow.mod)#
xprobfl = exp(B.xfl.yr$Year)/(1+exp(B.xfl.yr$Year))#back-transformed= these are the probabilities of flowering,
B.yfl.yr=coef(yflow.mod)#
yprobfl = exp(B.yfl.yr$Year)/(1+exp(B.yfl.yr$Year))#back-transformed= these are the probabilities of flowering,
write.csv(xprobfl,"xprobfl.csv")
write.csv(yprobfl,"yprobfl.csv")
#Look at model estimates versus probabilities calculated from data to compare:
#observed emergence by stage
numsdsflX<-tapply(emergX$tofl,list(emergX$Year,emergX$Stage_cur), sum)
numsdsX<-tapply(emergX$tofl,list(emergX$Year,emergX$Stage_cur), length)
propflX<-numsdsflX/numsdsX
propflX#
numsdsflY<-tapply(emergY$tofl,list(emergY$Year,emergY$Stage_cur), sum)
numsdsY<-tapply(emergY$tofl,list(emergY$Year,emergY$Stage_cur), length)
propflY<-numsdsflY/numsdsY
propflY#
xfl_mod_dat<-cbind(propflX[,1],xprobfl$Stage_curd,propflX[,2],xprobfl$Stage_curdv,propflX[,5],xprobfl$Stage_curv,propflX[,3],xprobfl$Stage_curfl,propflX[,4],xprobfl$Stage_curfr)
colnames(xfl_mod_dat)<-c("pfl_d_dat","pfl_d_mod","pfl_dv_dat","pfl_dv_mod","pfl_v_dat","pfl_v_mod","pfl_fl_dat","pfl_fl_mod","pfl_fr_dat","pfl_fr_mod")
yfl_mod_dat<-cbind(propflY[,1],yprobfl$Stage_curd,propflY[,2],yprobfl$Stage_curdv,propflY[,5],yprobfl$Stage_curv,propflY[,3],yprobfl$Stage_curfl,propflY[,4],yprobfl$Stage_curfr)
colnames(yfl_mod_dat)<-c("pfl_d_dat","pfl_d_mod","pfl_dv_dat","pfl_dv_mod","pfl_v_dat","pfl_v_mod","pfl_fl_dat","pfl_fl_mod","pfl_fr_dat","pfl_fr_mod")
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(xfl_mod_dat[,(i*2)-1],xfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfl_mod_dat[,(i*2)-1],yfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
for(i in 1:5){
plot(xfl_mod_dat[,(i*2)-1],xfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfl_mod_dat[,(i*2)-1],yfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
xfl_mod_dat
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfl_mod_dat[,(i*2)-1],yfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
#3) for flowering plants, probability of fruiting:too little data for the below!
flowX=emergX[emergX$tofl==1,]
flowY=emergY[emergY$tofl==1,]
flowX$Stage_cur<-factor(flowX$Stage_cur)
flowY$Stage_cur<-factor(flowY$Stage_cur)
flowX$Year<-factor(flowX$Year)
numsdsflY<-tapply(emergY$tofl,list(emergY$Year,emergY$Stage_cur), sum)
numsdsY<-tapply(emergY$tofl,list(emergY$Year,emergY$Stage_cur), length)
propflY<-numsdsflY/numsdsY
propflY#
xfl_mod_dat<-cbind(propflX[,1],xprobfl$Stage_curd,propflX[,2],xprobfl$Stage_curdv,propflX[,5],xprobfl$Stage_curv,propflX[,3],xprobfl$Stage_curfl,propflX[,4],xprobfl$Stage_curfr)
colnames(xfl_mod_dat)<-c("pfl_d_dat","pfl_d_mod","pfl_dv_dat","pfl_dv_mod","pfl_v_dat","pfl_v_mod","pfl_fl_dat","pfl_fl_mod","pfl_fr_dat","pfl_fr_mod")
yfl_mod_dat<-cbind(propflY[,1],yprobfl$Stage_curd,propflY[,2],yprobfl$Stage_curdv,propflY[,5],yprobfl$Stage_curv,propflY[,3],yprobfl$Stage_curfl,propflY[,4],yprobfl$Stage_curfr)
colnames(yfl_mod_dat)<-c("pfl_d_dat","pfl_d_mod","pfl_dv_dat","pfl_dv_mod","pfl_v_dat","pfl_v_mod","pfl_fl_dat","pfl_fl_mod","pfl_fr_dat","pfl_fr_mod")
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(xfl_mod_dat[,(i*2)-1],xfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfl_mod_dat[,(i*2)-1],yfl_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfl_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
numsdsflY
numsdsflX
write.csv(yfl_mod_dat,"cleared_vrcomp_probfl.csv")
write.csv(xfl_mod_dat,"control_vrcomp_probfl.csv")
flowX=emergX[emergX$tofl==1,]
flowY=emergY[emergY$tofl==1,]
flowX$Stage_cur<-factor(flowX$Stage_cur)
flowY$Stage_cur<-factor(flowY$Stage_cur)
flowX$Year<-factor(flowX$Year)
flowY$Year<-factor(flowY$Year)
xfr.mod <- glmer(tofr ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=flowX, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#probability of fruiting, conditioned on flowering
yfr.mod <- glmer(tofr ~ -1 +Stage_cur + (-1+Stage_cur|Year), data=flowY, control=glmerControl(optimizer="bobyqa",optCtrl=list(maxfun=100000)),family=binomial(link=logit))#probability of fruiting, conditioned on flowering
#convergence error- i think because there is compelte linear separate (all d plants both flower and fruit; no dv plants fruit for group Y; )
#for group X, all dv plants fo to fr and
#table(flowY$Stage_cur,flowY$Fate)
#table(flowX$Stage_cur,flowX$Fate)
B.xfr.yr=coef(xfr.mod)#
xprobfr = exp(B.xfr.yr$Year)/(1+exp(B.xfr.yr$Year))#back-transformed= these are the probabilities of fruiting,
write.csv(xprobfr,"xprobfr.csv")
B.yfr.yr=coef(yfr.mod)#
yprobfr = exp(B.yfr.yr$Year)/(1+exp(B.yfr.yr$Year))#back-transformed= these are the probabilities of fruiting,
write.csv(yprobfr,"yprobfr.csv")
#Look at model estimates versus probabilities calculated from data to compare:
#observed emergence by stage
numsdsfrX<-tapply(flowX$tofr,list(flowX$Year,flowX$Stage_cur), sum)
numsdsX<-tapply(flowX$tofr,list(flowX$Year,flowX$Stage_cur), length)
propfrX<-numsdsfrX/numsdsX
propfrX#
numsdsfrY<-tapply(flowY$tofr,list(flowY$Year,flowY$Stage_cur), sum)
numsdsY<-tapply(flowY$tofr,list(flowY$Year,flowY$Stage_cur), length)
propfrY<-numsdsfrY/numsdsY
propfrY#
xfr_mod_dat<-cbind(propfrX[,1],xprobfr$Stage_curd,propfrX[,2],xprobfr$Stage_curdv,propfrX[,5],xprobfr$Stage_curv,propfrX[,3],xprobfr$Stage_curfl,propfrX[,4],xprobfr$Stage_curfr)
colnames(xfr_mod_dat)<-c("pfr_d_dat","pfr_d_mod","pfr_dv_dat","pfr_dv_mod","pfr_v_dat","pfr_v_mod","pfr_fl_dat","pfr_fl_mod","pfr_fr_dat","pfr_fr_mod")
yfr_mod_dat<-cbind(propfrY[,1],yprobfr$Stage_curd,propfrY[,2],yprobfr$Stage_curdv,propfrY[,5],yprobfr$Stage_curv,propfrY[,3],yprobfr$Stage_curfl,propfrY[,4],yprobfr$Stage_curfr)
colnames(yfl_mod_dat)<-c("pfr_d_dat","pfr_d_mod","pfr_dv_dat","pfr_dv_mod","pfr_v_dat","pfr_v_mod","pfr_fl_dat","pfr_fl_mod","pfr_fr_dat","pfr_fr_mod")
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(xfr_mod_dat[,(i*2)-1],xfr_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xfr_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfr_mod_dat[,(i*2)-1],yfr_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfr_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
yfr_mod_dat
colnames(yfl_mod_dat)<-c("pfr_d_dat","pfr_d_mod","pfr_dv_dat","pfr_dv_mod","pfr_v_dat","pfr_v_mod","pfr_fl_dat","pfr_fl_mod","pfr_fr_dat","pfr_fr_mod")
yfr_mod_dat
yfr_mod_dat<-cbind(propfrY[,1],yprobfr$Stage_curd,propfrY[,2],yprobfr$Stage_curdv,propfrY[,5],yprobfr$Stage_curv,propfrY[,3],yprobfr$Stage_curfl,propfrY[,4],yprobfr$Stage_curfr)
colnames(yfr_mod_dat)<-c("pfr_d_dat","pfr_d_mod","pfr_dv_dat","pfr_dv_mod","pfr_v_dat","pfr_v_mod","pfr_fl_dat","pfr_fl_mod","pfr_fr_dat","pfr_fr_mod")
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(xfr_mod_dat[,(i*2)-1],xfr_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Control ",substr(colnames(xfr_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
quartz(width=10,height=6)
par(mfrow=c(2,3))
for(i in 1:5){
plot(yfr_mod_dat[,(i*2)-1],yfr_mod_dat[,(i*2)],type="p",pch=16,xlab="from data",ylab="model estimate",main=paste("Cleared ",substr(colnames(yfr_mod_dat)[i*2],1,6)), xlim=c(0,1),ylim=c(0,1))
abline(a=0,b=1)
}
write.csv(yfr_mod_dat,"cleared_vrcomp_probfr.csv")
write.csv(xfr_mod_dat,"control_vrcomp_probfr.csv")
setwd("~/git/isotria/analyses")
AllClimDat = read.csv("../data/climate_isotria_NH_1976_2016.csv", header = T)#These data are form multiple stations
unique(AllClimDat$NAME)
ClimDat=AllClimDat[which(substr(AllClimDat$NAME),1,8)=="LAKEPORT"),]
substr(AllClimDat$NAME),1,8)
ClimDat=AllClimDat[which(substr(AllClimDat$NAME,1,8)=="LAKEPORT"),]
rm(list=ls())
options(stringsAsFactors = FALSE)
# Set working directory:
if(length(grep("Lizzie", getwd())>0)) {    setwd("~/Documents/git/projects/treegarden/budreview/ospree/analyses")
} else
setwd("~/Documents/git/ospree")
# Load libraries
library(dplyr)
library(tidyr)
# 1. Get the data
d <- read.csv("input/ospree.csv")
# 2. Need to deal with some basic cleaning ... what are these columns and what should we do with them?
setwd("~/git/ospree")
# Load libraries
library(dplyr)
library(tidyr)
# 1. Get the data
d <- read.csv("input/ospree.csv")
# 2. Need to deal with some basic cleaning ... what are these columns and what should we do with them?
unique(d$X.1)
unique(d$X.2)
unique(d$X.3)
# 3. Add in Zohner data ... (need to rewrite code in zohner_addingtomaindata.R so that it works here, and move any code that cleans columns and deals with multiresp to clean_respvar.R ... ##
# source("zohner_addingtomaindata.R")
# 4. Clean up response variable names
source("cleaning/clean_respvar.R")
# 5. Clean up photoperiod #
d <- read.csv("input/ospree.csv")
setwd("~/git/ospree")
setwd("~/git/ospree/analyses")
# Load libraries
library(dplyr)
library(tidyr)
# 1. Get the data
d <- read.csv("input/ospree.csv")
# 2. Need to deal with some basic cleaning ... what are these columns and what should we do with them?
unique(d$X.1)
unique(d$X.2)
unique(d$X.3)
# 3. Add in Zohner data ... (need to rewrite code in zohner_addingtomaindata.R so that it works here, and move any code that cleans columns and deals with multiresp to clean_respvar.R ... ##
# source("zohner_addingtomaindata.R")
# 4. Clean up response variable names
source("cleaning/clean_respvar.R")
setwd("~/git/ospree")
#d2 <- read.csv("analyses/output/ospree_clean.csv")#old version
d3 <- read.csv("analyses/output/ospree_master_clean.csv")#new version
substr(AllClimDat$NAME),1,8)
unique(d3$chilltemp)
ospree <- read.csv("analyses/output/ospree_clean_withchill.csv", header=TRUE)
ospree<-subset(ospree, woody=="yes")
#First, just explore a bit:
dim(ospree)
head(ospree)
sort(unique(ospree$respvar.simple))#the different response variables
#Look at just days to bb data:
ospree.daysbb <- ospree[which(ospree$respvar.simple=="daystobudburst"),]
ospree.daysbb$response<-as.numeric(ospree.daysbb$response)
ospree.daysbb$Total_Chilling_Hours<-as.numeric(ospree.daysbb$Total_Chilling_Hours)
ospree.daysbb$forcetemp<-as.numeric(ospree.daysbb$forcetemp)
quartz()
hist(ospree.daysbb$response)
plot(ospree.daysbb$Total_Chilling_Hours,ospree.daysbb$response.time)
plot(ospree.daysbb$Total_Chilling_Hours,ospree.daysbb$response, ylim=c(0,5))
ospree.percbb <- ospree[which(ospree$respvar=="percentbudburst"),]
quartz()
plot(ospree.percbb$Total_Chilling_Hours,ospree.percbb$response)
dim(ospree.percbb) # 3281  rows
quartz()
plot(ospree.percbb$Total_Chilling_Hours,ospree.percbb$response)
quartz()
hist(ospree.daysbb$response)
plot(ospree.daysbb$Total_Chilling_Hours,ospree.daysbb$response.time)
plot(ospree.daysbb$Total_Chilling_Hours,ospree.daysbb$response, ylim=c(0,5))
plot(ospree.daysbb$Total_Chilling_Hours,ospree.daysbb$response, ylim=c(0,5))
dim(ospree.daysbb[which(ospree.daysbb$response!=1),])
dim(ospree.daysbb)
dim(ospree.daysbb[which(ospree.daysbb$response==1),])
2177/2677
ospree.daysbb <- ospree[which(ospree$respvar.simple=="daystobudburst"),]
dim(ospree.daysbb[which(ospree.daysbb$response==1),])
dim(ospree.daysbb[which(ospree.daysbb$response!=1),])
ospree.daysbb[which(ospree.daysbb$response!=1),]
unique(ospree.daysbb[which(ospree.daysbb$response!=1),]$response
)
setwd("~/git/ospree")
d3 <- read.csv("analyses/output/ospree_clean.csv.csv")#uses the cleaned data file created from Lizzie's "cleanmerge_all.R" code
setwd("~/git/ospree")
d3 <- read.csv("analyses/output/ospree_master_clean.csv")#
#this file should use the cleaned data file created from Lizzie's "cleanmerge_all.R" code
colnames(d3)[17]<-"fsdate_tofix"#the date format in this new file needs to be changed, for this code to work
d3$fieldsample.date<-strptime(strptime(d3$fsdate_tofix, format = "%m/%d/%Y"),format = "%Y-%m-%d")
d <- subset(d3, woody=="yes")
# make two data frames. North America and Europe, the lat longs and years.
d$continent <- tolower(d$continent)
d$datasetID <- as.character(d$datasetID)
d$provenance.lat <- as.numeric(as.character(d$provenance.lat))
d$provenance.long <- as.numeric(as.character(d$provenance.long))
d$year <- as.numeric(as.character(d$year))
d$fieldsample.date<-as.character(as.Date(d$fieldsample.date,"%m/%d/%y")) #needed for new version
d <- as_data_frame(d)
##add new column that combines datasetID, provenance.lat, provenance.long, and field sample.date for later indexing
d$ID_fieldsample.date<-paste(d$datasetID,d$provenance.lat,d$provenance.long,d$fieldsample.date, sep="_")
dat <- read.csv("analyses/output/ospree_master_clean.csv") # change to master clean file? - CC
colnames(dat)[17]<-"fsdate_tofix"#the date format in this new file needs to be changed, for this code to work
dat$fieldsample.date<-strptime(strptime(dat$fsdate_tofix, format = "%m/%d/%Y"),format = "%Y-%m-%d")
#use only woody species
dat2 <- subset(dat, woody=="yes")
# make two data frames. North America and Europe, the lat longs and years.
dat2$continent <- tolower(dat2$continent)
dat2$datasetID <- as.character(dat2$datasetID)
dat2$provenance.lat <- as.numeric(as.character(dat2$provenance.lat))
dat2$provenance.long <- as.numeric(as.character(dat2$provenance.long))
dat2$year <- as.numeric(as.character(dat2$year))
dat2$fieldsample.date<-as.character(as.Date(dat2$fieldsample.date,"%m/%d/%y")) #needed for new version
dat2 <- as_data_frame(dat2)
#Make a column that indexes the study, provenance latitude,provenance longitude, and field sample date, in order to calculate field chilling
dat2$ID_fieldsample.date<-paste(dat2$datasetID,dat2$provenance.lat,dat2$provenance.long,dat2$fieldsample.date, sep="_")
dat <- read.csv("analyses/output/ospree_master_clean.csv") # change to master clean file? - CC
colnames(dat)[17]<-"fsdate_tofix"#the date format in this new file needs to be changed, for this code to work
dat$fieldsample.date<-strptime(strptime(dat$fsdate_tofix, format = "%m/%d/%Y"),format = "%Y-%m-%d")
#use only woody species
dat2 <- subset(dat, woody=="yes")
# make two data frames. North America and Europe, the lat longs and years.
dat2$continent <- tolower(dat2$continent)
dat2$datasetID <- as.character(dat2$datasetID)
dat2$provenance.lat <- as.numeric(as.character(dat2$provenance.lat))
dat2$provenance.long <- as.numeric(as.character(dat2$provenance.long))
dat2$year <- as.numeric(as.character(dat2$year))
dat2$fieldsample.date<-as.character(as.Date(dat2$fieldsample.date,"%m/%d/%y")) #needed for new version
dat2 <- as_data_frame(dat2)
#Make a column that indexes the study, provenance latitude,provenance longitude, and field sample date, in order to calculate field chilling
dat2$ID_fieldsample.date<-paste(dat2$datasetID,dat2$provenance.lat,dat2$provenance.long,dat2$fieldsample.date, sep="_")
#Make a column that indexes the experimental chilling treatment (including chilltemp, chillphotoperiod & chilldays), in order to calculate field chilling
dat2$ID_chilltreat<-paste(dat2$datasetID,dat2$chilltemp,dat2$chilldays,sep=".")
##### Calculate experimental chilling, using chillday and chilltemp.
###there are many non-numeric values in the chilltemp and chilldays columns- these are unusable currently so remove:
#want table with datasetID chilling days, chilling temperature,  treat for each study.
chilldat <- dat2 %>% # start with the data frame
distinct(ID_chilltreat,.keep_all = TRUE) %>% # establishing grouping variables
dplyr::select(datasetID, chilltemp, chilldays, year,ID_chilltreat)
chilldat$chilltemp
dat <- read.csv("analyses/output/ospree_master_clean.csv") # change to master clean file? - CC
d <- read.csv("analyses/output/ospree_master_clean.csv") # change to master clean file? - CC
dat$fieldsample.date<-strptime(strptime(dat$fsdate_tofix, format = "%m/%d/%Y"),format = "%Y-%m-%d")
dat <- read.csv("analyses/output/ospree_master_clean.csv") #this file should use the cleaned data file created from Lizzie's "cleanmerge_all.R" code, after the chilltemps and chilldays have been cleaning with cleanin_chilltemp.R
colnames(dat)[17]<-"fsdate_tofix"#the date format in this new file needs to be changed, for this code to work
dat$fieldsample.date<-strptime(strptime(dat$fsdate_tofix, format = "%m/%d/%Y"),format = "%Y-%m-%d")
#use only woody species
dat2 <- subset(dat, woody=="yes")
# make two data frames. North America and Europe, the lat longs and years.
dat2$continent <- tolower(dat2$continent)
dat2$datasetID <- as.character(dat2$datasetID)
dat2$provenance.lat <- as.numeric(as.character(dat2$provenance.lat))
dat2$provenance.long <- as.numeric(as.character(dat2$provenance.long))
dat2$year <- as.numeric(as.character(dat2$year))
dat2$fieldsample.date<-as.character(as.Date(dat2$fieldsample.date,"%m/%d/%y")) #needed for new version
dat2 <- as_data_frame(dat2)
#Make a column that indexes the study, provenance latitude,provenance longitude, and field sample date, in order to calculate field chilling
dat2$ID_fieldsample.date<-paste(dat2$datasetID,dat2$provenance.lat,dat2$provenance.long,dat2$fieldsample.date, sep="_")
#Make a column that indexes the experimental chilling treatment (including chilltemp, chillphotoperiod & chilldays), in order to calculate field chilling
dat2$ID_chilltreat<-paste(dat2$datasetID,dat2$chilltemp,dat2$chilldays,sep=".")
##### Calculate experimental chilling, using chillday and chilltemp.
###there are many non-numeric values in the chilltemp and chilldays columns- these are unusable currently so remove:
#want table with datasetID chilling days, chilling temperature,  treat for each study.
chilldat <- dat2 %>% # start with the data frame
distinct(ID_chilltreat,.keep_all = TRUE) %>% # establishing grouping variables
dplyr::select(datasetID, chilltemp, chilldays, year,ID_chilltreat)
chilldat$chilltemp<-as.numeric(chilldat$chilltemp)
chilldat$chilldays<-as.numeric(chilldat$chilldays)
chilldat<- chilldat[apply(chilldat, 1, function(x) all(!is.na(x))),] # only keep rows of all not na
expchillcalcs <- vector()
chilldat$chilltemp
chilldat <- dat2 %>% # start with the data frame
distinct(ID_chilltreat,.keep_all = TRUE) %>% # establishing grouping variables
dplyr::select(datasetID, chilltemp, chilldays, year,ID_chilltreat)
chilldat$chilltemp
unique(dat2$chilltemp)
dat2[which(dat2$chilltemp=="High"),]
dat2[which(dat2$chilltemp=="Low"),]#this is skre08
dat2[which(dat2$chilltemp=="mean of 0, 3, 6"),]
dat2[which(dat2$chilltemp=="elevated"),]#skuterud94
unique(dat2$chilltemp)#Need to fix
dat2[which(dat2$chilltemp=="negative 23 to 13 degrees Celsius"),]#pagter15
dat2[which(dat2$chilltemp=="ambient plus days at 4C"),]#pagter15
dat2[which(dat2$chilltemp=="neg 3,2"),]#pagter15
dat2[which(dat2$chilltemp=="6,.5"),]#man10
dat2[which(dat2$chilltemp=="-3, 3"),]#man10
dat2[which(dat2$chilltemp=="8, 8, -4"),]#man10
dat2[which(dat2$chilltemp=="8, 4, 0"),]#jones12
dat2[which(dat2$chilltemp=="4, 0, -4"),]#jones12
dat2[which(dat2$chilltemp=="0, 4, 8"),]#jones12
unique(dat2$chilltemp)#Need to fix
dat2[which(dat2$chilltemp=="-4, 8, 8"),]#jones12
dat2[which(dat2$chilltemp=="-4, 0, 4""),]#jones12
colnames(dat)[17]<-"fsdate_tofix"#the date format in this new file needs to be changed, for this code to work
